/*
    Copyright (C) 1999-2005 by Mark D. Hill and David A. Wood for the
    Wisconsin Multifacet Project.  Contact: gems@cs.wisc.edu
    http://www.cs.wisc.edu/gems/
    --------------------------------------------------------------------
    This file is part of the SLICC (Specification Language for
    Implementing Cache Coherence), a component of the Multifacet GEMS
    (General Execution-driven Multiprocessor Simulator) software
    toolset originally developed at the University of Wisconsin-Madison.
    SLICC was originally developed by Milo Martin with substantial
    contributions from Daniel Sorin.
    Substantial further development of Multifacet GEMS at the
    University of Wisconsin was performed by Alaa Alameldeen, Brad
    Beckmann, Jayaram Bobba, Ross Dickson, Dan Gibson, Pacia Harper,
    Derek Hower, Milo Martin, Michael Marty, Carl Mauer, Michelle Moravan,
    Kevin Moore, Manoj Plakal, Daniel Sorin, Haris Volos, Min Xu, and Luke
Yen.
    --------------------------------------------------------------------
    If your use of this software contributes to a published paper, we
    request that you (1) cite our summary paper that appears on our
    website (http://www.cs.wisc.edu/gems/) and (2) e-mail a citation
    for your published paper to gems@cs.wisc.edu.
    If you redistribute derivatives of this software, we request that
    you notify us and either (1) ask people to register with us at our
    website (http://www.cs.wisc.edu/gems/) or (2) collect registration
    information and periodically send it to us.
    --------------------------------------------------------------------
    Multifacet GEMS is free software; you can redistribute it and/or
    modify it under the terms of version 2 of the GNU General Public
    License as published by the Free Software Foundation.
    Multifacet GEMS is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with the Multifacet GEMS; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307, USA
    The GNU General Public License is contained in the file LICENSE.
### END HEADER ###
*/
/*
 * $Id: MOESI_CMP_token-dir.sm 1.6 05/01/19 15:48:35-06:00
mikem@royal16.cs.wisc.edu $
*/ /**
Modified by Andrew Hay (andrewh@cs.auckland.ac.nz), 2011
*/
machine(L1Cache, "MESIF protocol") {
    // Message buffers: this node TO the network
    MessageBuffer requestFromL1Cache, network="To", virtual_network="0",
ordered="false";
    MessageBuffer responseFromL1Cache, network="To", virtual_network="1",
ordered="false";
    MessageBuffer dataResponseFromL1Cache, network="To", virtual_network="4",
ordered="false";
    // Message buffers: this node FROM the network
    MessageBuffer requestToL1Cache, network="From", virtual_network="0",
ordered="false";
    MessageBuffer responseToL1Cache, network="From", virtual_network="1",
ordered="false";
    MessageBuffer dataResponseToL1Cache, network="From", virtual_network="4",
ordered="false";
    // STATES
    enumeration(State, desc="Cache states", default="L1Cache_State_I") {
        // Base states
        //NP,     "NP",
        I,      "I",
        S,      "S",
E, "E",
F, "F",
        M,      "M",
        O,      "O",
as the ’FM’ state";
  desc="Not Present";
desc="Idle";
desc="Shared";
desc="Exclusive";
desc="Forward";
desc="Modified";
desc="Forward+Modified, MESIF paper denotes this
        // Transient states I-M
        IM,     "IM",       desc="Transiting to exclusive (then doing a
store), not all replies nor data";
        IMH,    "IMH",      desc="Transiting to exclusive (then doing a
store), all replies but no data";
        IMF,    "IMF",      desc="Modified forwarded - has data, not all
replies";
        IMFH,   "IMFH",     desc="Modified forwarded - has data, all
replies";
        // Conflicting states
        IMC,    "IMC",
        IMHC,   "IMHC",
        IMFC,   "IMFC",
        IMFHC,  "IMFHC",
        IMWX,   "IMWX",
data -- then transfer";
        IMWC,   "IMWC",
desc="IM but with conflicts";
desc="IMH but with conflicts";
desc="IMF but with conflicts";
desc="IMFH but with conflicts";
desc="All replies but home has told to wait for
desc="All replies but home has told to wait for
data";
data";
data";
all replies";
// Transferring line states
EI,     "EI",
MI,     "MI",
FI,     "FI",
OI,     "OI",
ES,     "ES",
MS,     "MS",
FS,     "FS",
OS,     "OS",
desc="Forwarded data, awaiting DACK";
desc="Forwarded data, awaiting DACK";
desc="Forwarded data, awaiting DACK";
desc="Forwarded data, awaiting DACK";
desc="Forwarded data, awaiting DACK";
desc="Forwarded data, awaiting DACK";
desc="Forwarded data, awaiting DACK";
desc="Forwarded data, awaiting DACK";
desc="Writing data back to memory on L1
        WB,     "WB",
replacement";
// Transient states I-S
                    desc="Transiting to shared, not all replies nor
                    desc="Transiting to shared, all replies, no
                    desc="Transiting to shared, forwarded data, not
                    desc="Transiting to shared, forwarded data, all
IS,     "IS",
ISH,    "ISH",
ISF,    "ISF",
        ISFH,   "ISFH",
replies";
ISFM,   "ISFM",
ISFMH,  "ISFMH",
// Conflicting states - S, shared
ISC,    "ISC",
ISHC,   "ISHC",
ISFC,   "ISFC",
desc="IS but with conflicts";
desc="ISH but with conflicts";
desc="ISF but with conflicts";
desc="ISF but data is modified";
desc="ISFH but data is modified";
data";
ISFHC,  "ISFHC",
ISFMC,  "ISFMC",
ISFMHC, "ISFMHC",
desc="ISFH but with conflicts";
desc="ISFC but data is modified";
desc="ISFHC but data is modified";
        ISWX,   "ISWX",
data -- then transfer as forward";
                    desc="All replies but home has told to wait for
ISWC,   "ISWC",     desc="All replies but home has told to wait for
// Conflicting states - S, invalidating
ISCI,   "ISCI",
ISHCI,  "ISHCI",
ISFCI,  "ISFCI",
ISFHCI, "ISFHCI",
ISFMCI, "ISFMCI",
ISFMHCI,"ISFMHCI",  desc="ISFHCI but data is modified";
ISECI,  "ISECI",
ISEHCI, "ISEHCI",
ISMCI,  "ISMCI",
ISMHCI, "ISMHCI",
ISWXI,  "ISWXI",
desc="ISFCI but forwarded in state E";
desc="ISFHCI but forwarded in state E";
desc="ISFCI but forwarded in state M";
desc="ISFHCI but forwarded in state M";
desc="ISWX but must invalidate at the end";
desc="ISC but must invalidate at the end";
desc="ISHC but must invalidate at the end";
desc="ISFC but must invalidate at the end";
desc="ISFHC but must invalidate at the end";
desc="ISFCI but data is modified";
// Transient states F-M
FM,     "FM",       desc="Transiting to exclusive, not all replies";
FMH,    "FMH",      desc="Transiting to exclusive, all replies";
// Conflicting states - invalidating
FMC,    "FMC",      desc="FM but with conflicts";
FMHC,   "FMHC",     desc="FMH but with conflicts";
// Transient states Owned/Forward to M
        WR,     "WR",       desc="Transiting to exclusive, not all replies --
already had the forward state";
        WRH,    "WRH",      desc="Transiting to exclusive, all replies --
already had the forward state";
}
// EVENTS
enumeration(Event, desc="Cache events") {
    Load,           desc="Load request from the processor";
    Store,          desc="Store request from the processor";
    Ifetch,         desc="Instruction fetch request from the processor";
    L1_Replacement, desc="L1 replacement";
WB_Ack,
desc="Ack from L2, write back successful";
desc="GETX from other processor";
desc="GETS from other processor";
Fwd_GETX,
Fwd_GETS,
Fwd_GET_INSTR,  desc="GET_INSTR from other processor";
        Fwd_Recycle,    desc="GET from other processor, must be recycled as
this is the second one in the same request";
        IACK,           desc="Acknowledgement of request, invalid state";
        IACK_Final,     desc="Final acknowledgement of request, invalid
state";
        SACK,           desc="Acknowledgement of request, shared state";
        SACK_Final,     desc="Final acknowledgement of request, shared
state";
        DACK,           desc="Data acknowledgement, can now respond to other
requests";
        DataF,          desc="Received shared data from a cache";
        DataF_Final,    desc="Received shared data from a cache, no more acks
needed";
        DataFM,         desc="Received forwarded/modified data from a cache";
        DataFM_Final,   desc="Received forwarded/modified data from a cache,
no more acks needed";
        DataE,          desc="Received exclusive data from a cache";
        DataE_Final,    desc="Received exclusive data from a cache, no more
acks needed";
        DataM,          desc="Received modified data from a cache";
        DataM_Final,    desc="Received modified data from a cache, no more
acks needed";
        //TxnF,           desc="Received transferred shared data from a
cache";
        //TxnFM,          desc="Received transferred forwarded/modified data
from a cache";
        //TxnE,
cache";
cache";
desc="Received transferred exclusive data from a
desc="Received transferred modified data from a
    desc="GETX from processor we are transferring
    desc="GETS from processor we are transferring
//TxnM,
Extra_Fwd_GETX,
to";
to";
transferring to";
        DataE_Home,
        Ack_Home,
needed";
        Transfer,       desc="Ack from home and Transfer to another node";
        Data_Transfer,  desc="Data from home and Transfer to anther node";
        Wait,           desc="Wait for data";
        Wait_Transfer,  desc="Wait for data and then Transfer to another
node";
        //Extra_Request,  desc="Triggered when a getX/S is received but we
are already transferring to that node";
    }
    // Internal types
    // CacheEntry
    structure(Entry, desc="...", interface="AbstractCacheEntry") {
Extra_Fwd_GETS,
Extra_Fwd_GET_INSTR,  desc="GET_INSTR from processor we are
                desc="Received exclusive data from home";
                desc="Received Ack from home";
                desc="Conflict message received";
Conflict_Final, desc="Conflict message received, no more acks
Conflict,
      State CacheState,
      bool Dirty,
memory)?";
      DataBlock DataBlk,
desc="cache state";
desc="Is the data dirty (different than
desc="data for the block";
}
// TBE fields
structure(TBE, desc="...") {
       desc="Physical address for this TBE";
desc="Transient state";
Address Address,
State TBEState,
DataBlock DataBlk,
bool Dirty, default="false",   desc="data is dirty";
      PrefetchBit Prefetch,
prefetch";
      MachineID L1_FwdData,
data to us.";
      desc="Buffer for the data block";
desc="Set if this was caused by a
   desc="ID of the L1 cache that forwarded
      MachineID TransferMachine,
should transfer the data to when we get it";
      //int PendingAcks, default="0", desc="number of pending acks";
      NetDest PendingAcks,              desc="The set of machines that has
sent acks";
      AccessModeType AccessMode,    desc="user/supervisor access type";
      MachineIDset ConflictMachs, desc="Stores the first machine to conflict
with this one if in a conflict";
      MachineIDset RequestMach, desc="Stores the machines that have sent a
request to this machine already";
}
    // External types
    external_type(CacheMemory) {
      bool cacheAvail(Address);
      Address cacheProbe(Address);
      void allocate(Address);
      void deallocate(Address);
      Entry lookup(Address);
      void changePermission(Address, AccessPermission);
      bool isTagPresent(Address);
}
    external_type(TBETable) {
      TBE lookup(Address);
      void allocate(Address);
      void deallocate(Address);
      bool isPresent(Address);
desc="ID of the L1 cache that we
    }
    // global variables
    TBETable L1_TBEs, template_hack="<L1Cache_TBE>";
    CacheMemory L1IcacheMemory, template_hack="<L1Cache_Entry>",
constructor_hack=’L1_CACHE_NUM_SETS_BITS,L1_CACHE_ASSOC,MachineType_L1Cache,in
t_to_string(i)+"_L1I"’,
                                abstract_chip_ptr="true";
    CacheMemory L1DcacheMemory, template_hack="<L1Cache_Entry>",
constructor_hack=’L1_CACHE_NUM_SETS_BITS,L1_CACHE_ASSOC,MachineType_L1Cache,in
t_to_string(i)+"_L1D"’,
                                abstract_chip_ptr="true";
    MessageBuffer mandatoryQueue, ordered="false", abstract_chip_ptr="true";
    Sequencer sequencer, abstract_chip_ptr="true", constructor_hack="i";
// Functions
    Entry getL1CacheEntry(Address addr), return_by_ref="yes" {
        if (L1DcacheMemory.isTagPresent(addr)) {
            return L1DcacheMemory[addr];
        }
        else {
            return L1IcacheMemory[addr];
} }
    Event mandatory_request_type_to_event(CacheRequestType type) {
        if (type == CacheRequestType:LD) {
            return Event:Load;
        } else if (type == CacheRequestType:IFETCH) {
            return Event:Ifetch;
        } else if ((type == CacheRequestType:ST) || (type ==
CacheRequestType:ATOMIC)) {
            return Event:Store;
        } else {
            error("Invalid CacheRequestType");
        }
}
    void changeL1Permission(Address addr, AccessPermission permission) {
        if (L1DcacheMemory.isTagPresent(addr)) {
            return L1DcacheMemory.changePermission(addr, permission);
        }
        else if(L1IcacheMemory.isTagPresent(addr)) {
            return L1IcacheMemory.changePermission(addr, permission);
}
else {
            error("cannot change permission, L1 block not present");
        }
}
    bool isL1CacheTagPresent(Address addr) {
        return (L1DcacheMemory.isTagPresent(addr) ||
L1IcacheMemory.isTagPresent(addr));
    }
    void setState(Address addr, State state) {
        assert((L1DcacheMemory.isTagPresent(addr) &&
L1IcacheMemory.isTagPresent(addr)) == false);
        // MUST CHANGE
        if(L1_TBEs.isPresent(addr)) {
            L1_TBEs[addr].TBEState := state;
        }
        if (isL1CacheTagPresent(addr)) {
            getL1CacheEntry(addr).CacheState := state;
            // Set permission
            if (state == State:I) {
                changeL1Permission(addr, AccessPermission:Invalid);
State:E) {
}
//TODO: why is E read only?
else if (state == State:S || state == State:F || state ==
    changeL1Permission(addr, AccessPermission:Read_Only);
}
else if (state == State:M) {
    changeL1Permission(addr, AccessPermission:Read_Write);
}
else {
    changeL1Permission(addr, AccessPermission:Busy);
}
} }
    State getState(Address addr) {
        if((L1DcacheMemory.isTagPresent(addr) &&
L1IcacheMemory.isTagPresent(addr)) == true){
            DEBUG_EXPR(id);
            DEBUG_EXPR(addr);
        }
        assert((L1DcacheMemory.isTagPresent(addr) &&
L1IcacheMemory.isTagPresent(addr)) == false);
        if(L1_TBEs.isPresent(addr)) {
            return L1_TBEs[addr].TBEState;
        }
        else if (isL1CacheTagPresent(addr)) {
            return getL1CacheEntry(addr).CacheState;
        }
        return State:I;
    }
    void registerReply(Address addr, MachineID sender) {
        L1_TBEs[addr].PendingAcks.add(sender);
}
    // Includes the current ack as well (since registerReply is called first)
    bool acksRemaining(Address addr) {
        return L1_TBEs[addr].PendingAcks.count() < numberOfL1Cache(); // less
than number of other L1’s + L2
    }
    void whoSentThis(MachineID m, ResponseMsg msg, int param) {
    }
    bool alreadySeenRequestingNode(Address addr, MachineID m) {
        if (L1_TBEs.isPresent(addr)) {
            return L1_TBEs[addr].RequestMach.contains(m);
        }
        else {
            return false;
} }
    // Returns true if this is a post transfer intermediate state.
    bool transferstate(State s) {
        return s == State:MI || s == State:IMWC || s == State:IMWX || s ==
State:FS || s == State:OS || s == State:ISWC ||
               s == State:ISWX || s == State:ISWXI || s == State:FI || s ==
State:OI || s == State:EI || s == State:MS ||
               s == State:ES;
}
// Out ports
    out_port(requestNetwork_out, RequestMsg, requestFromL1Cache);
    out_port(responseNetwork_out, RequestMsg, responseFromL1Cache);
    out_port(dataResponseNetwork_out, RequestMsg, dataResponseFromL1Cache);
// In ports
    // It’s important to handle requests from other caches before own
requests for correctness.
    // Basically, because when going from a MI or similar state to I, those
buffered requests MUST be dealt
    // with before dealing with a load or store (screws up the conflict
reporting stuff)
    in_port(requestNetwork_in, RequestMsg, requestToL1Cache) {
        if (requestNetwork_in.isReady()) {
            peek(requestNetwork_in, RequestMsg) {
                assert(in_msg.Destination.isElement(machineID));
                // Check if this request is in fact being forfilled by a
transfer, if so, remove it from the queue.
                /*if (L1_TBEs.isPresent(in_msg.Address) &&
machineID &&
in_msg.Requestor) {
L1_TBEs[in_msg.Address].TransferMachine !=
L1_TBEs[in_msg.Address].TransferMachine ==
machineID &&
in_msg.Requestor) {
            L1_TBEs[in_msg.Address].TransferMachine ==
if (in_msg.Type == CoherenceRequestType:GETX) {
    trigger(Event:Extra_Fwd_GETX, in_msg.Address);
}
else if (in_msg.Type == CoherenceRequestType:GETS) {
    trigger(Event:Extra_Fwd_GETS, in_msg.Address);
}
else if (in_msg.Type == CoherenceRequestType:GET_INSTR) {
    trigger(Event:Extra_Fwd_GET_INSTR, in_msg.Address);
    trigger(Event:Extra_Request, in_msg.Address);
}*/
if (L1_TBEs.isPresent(in_msg.Address) &&
                L1_TBEs[in_msg.Address].TransferMachine !=
} }
                else if (in_msg.Type == CoherenceRequestType:GETX) {
                    // upgrade transforms to GETX due to race
                    if (alreadySeenRequestingNode(in_msg.Address,
in_msg.Requestor)) {
                        trigger(Event:Fwd_Recycle, in_msg.Address);
                    }
                    else {
                        trigger(Event:Fwd_GETX, in_msg.Address);
} }
                else if (in_msg.Type == CoherenceRequestType:GETS) {
                    if (alreadySeenRequestingNode(in_msg.Address,
in_msg.Requestor)) {
                        trigger(Event:Fwd_Recycle, in_msg.Address);
                    }
                    else {
                        trigger(Event:Fwd_GETS, in_msg.Address);
} }
                else if (in_msg.Type == CoherenceRequestType:GET_INSTR) {
                    if (alreadySeenRequestingNode(in_msg.Address,
in_msg.Requestor)) {
                        trigger(Event:Fwd_Recycle, in_msg.Address);
                    }
                    else {
                        trigger(Event:Fwd_GET_INSTR, in_msg.Address);
} }
                else {
                    error("Invalid forwarded request type");
} }
    in_port(mandatoryQueue_in, CacheMsg, mandatoryQueue, desc="...") {
        if (mandatoryQueue_in.isReady()) {
            peek(mandatoryQueue_in, CacheMsg) {
                if (in_msg.Type == CacheRequestType:IFETCH) {
                    // Check to see if it is in the OTHER L1
                    if (L1DcacheMemory.isTagPresent(in_msg.Address)) {
                        // The block is in the wrong L1, put the request on
the queue to the shared L2
                        trigger(Event:L1_Replacement, in_msg.Address);
} }
for it.
in_msg.Address);
                    }
}
if (L1IcacheMemory.isTagPresent(in_msg.Address)) {
    // The tag matches for the L1, so the L1 asks the L2
    trigger(mandatory_request_type_to_event(in_msg.Type),
                    else {
                        if (L1IcacheMemory.cacheAvail(in_msg.Address)) {
                            // L1 does’t have the line, but we have space for
it in the L1 so let’s see if the L2 has it
trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.Address);
                        }
                        else {
                            // No room in the L1, so we need to make room in
the L1
                            trigger(Event:L1_Replacement,
L1IcacheMemory.cacheProbe(in_msg.Address));
} }
                }
                // Data Access
                else {
                    if (L1DcacheMemory.isTagPresent(in_msg.Address)) {
                        // The tag matches for the L1, so the L1 fetches the
line.  We know it can’t be in the L2 due to exclusion
                        trigger(mandatory_request_type_to_event(in_msg.Type),
in_msg.Address);
in the L1
} else {
    if (L1DcacheMemory.cacheAvail(in_msg.Address)) {
    // L1 does’t have the line, but we have space for it
trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.Address);
                        } else {
                            // No room in the L1, so we need to make room
                            trigger(Event:L1_Replacement,
L1DcacheMemory.cacheProbe(in_msg.Address));
} }
} }
} }
    in_port(responseNetwork_in, ResponseMsg, responseToL1Cache) {
        if (responseNetwork_in.isReady()) {
            peek(responseNetwork_in, ResponseMsg) {
                assert(in_msg.Destination.isElement(machineID));
                if (in_msg.SenderMachine == MachineType:L1Cache) {
                    if (in_msg.Type == CoherenceResponseType:IACK) {
                        registerReply(in_msg.Address, in_msg.Sender);
                        whoSentThis(in_msg.Sender, in_msg,
L1_TBEs[in_msg.Address].PendingAcks.count());
                        if (acksRemaining(in_msg.Address)) {
                            trigger(Event:IACK, in_msg.Address);
}
else {
                            trigger(Event:IACK_Final, in_msg.Address);
                        }
                    }
                    else if (in_msg.Type == CoherenceResponseType:SACK) {
                        registerReply(in_msg.Address, in_msg.Sender);
                        if (acksRemaining(in_msg.Address)) {
                            trigger(Event:SACK, in_msg.Address);
}
else {
                            trigger(Event:SACK_Final, in_msg.Address);
                        }
}
{
else if (in_msg.SenderMachine == MachineType:L2Cache) {
    if (in_msg.Type == CoherenceResponseType:DataF_E) {
        trigger(Event:DataE_Home, in_msg.Address);
    }
    else if (in_msg.Type == CoherenceResponseType:ACK) {
        trigger(Event:Ack_Home, in_msg.Address);
    }
    else if (in_msg.Type == CoherenceResponseType:XFR) {
        trigger(Event:Transfer, in_msg.Address);
    }
    else if (in_msg.Type == CoherenceResponseType:DXFR) {
        trigger(Event:Data_Transfer, in_msg.Address);
    }
    else if (in_msg.Type == CoherenceResponseType:Wait) {
        trigger(Event:Wait, in_msg.Address);
    }
    else if (in_msg.Type == CoherenceResponseType:WaitXFR) {
        trigger(Event:Wait_Transfer, in_msg.Address);
    }
    else if (in_msg.Type == CoherenceResponseType:MEMORY_ACK)
        trigger(Event:WB_Ack, in_msg.Address);
    }
} }
else if (in_msg.Type == CoherenceResponseType:Conflict) {
    registerReply(in_msg.Address, in_msg.Sender);
    if (acksRemaining(in_msg.Address)) {
        trigger(Event:Conflict, in_msg.Address);
}
else {
        trigger(Event:Conflict_Final, in_msg.Address);
    }
                    // Home, being an L2 cache, also acts as a Node (a
passive one that makes no requests)
                    else if (in_msg.Type == CoherenceResponseType:IACK) {
                        registerReply(in_msg.Address, in_msg.Sender);
}
                    // else if (in_msg.Type ==
CoherenceResponseType:DataF_FM) {
{
} }
} }
if (acksRemaining(in_msg.Address)) {
    trigger(Event:IACK, in_msg.Address);
}
else {
    trigger(Event:IACK_Final, in_msg.Address);
}
//     if (acksRemaining(in_msg.Address)) {
//
//     }
//     else {
//
//       }
//       else {
//
// } // }
trigger(Event:DataM_Final, in_msg.Address);
trigger(Event:DataFM, in_msg.Address);
//
//     }
// }
// else if (in_msg.Type == CoherenceResponseType:DataF_M)
//       if (acksRemaining(in_msg.Address)) {
trigger(Event:DataFM_Final, in_msg.Address);
trigger(Event:DataM, in_msg.Address);
// Data forward from L1 caches and DACKS
in_port(dataResponseNetwork_in, ResponseMsg, dataResponseToL1Cache) {
    if (dataResponseNetwork_in.isReady()) {
        peek(dataResponseNetwork_in, ResponseMsg) {
            if (in_msg.Type == CoherenceResponseType:DataF_F ||
                in_msg.Type == CoherenceResponseType:DataF_E ||
                in_msg.Type == CoherenceResponseType:DataF_M ||
    in_msg.Type == CoherenceResponseType:DataF_FM) {
    registerReply(in_msg.Address, in_msg.Sender);
}
if (in_msg.Type == CoherenceResponseType:DataF_F ||
    in_msg.Type == CoherenceResponseType:TxnF_F) {
    if (acksRemaining(in_msg.Address)) {
        trigger(Event:DataF, in_msg.Address);
}
else {
        trigger(Event:DataF_Final, in_msg.Address);
    }
}
else if (in_msg.Type == CoherenceResponseType:DataF_E ||
         in_msg.Type == CoherenceResponseType:TxnF_E) {
    if (acksRemaining(in_msg.Address)) {
        trigger(Event:DataE, in_msg.Address);
}
else {
        trigger(Event:DataE_Final, in_msg.Address);
    }
}
else if (in_msg.Type == CoherenceResponseType:DataF_M ||
         in_msg.Type == CoherenceResponseType:TxnF_M) {
    if (acksRemaining(in_msg.Address)) {
        trigger(Event:DataM, in_msg.Address);
}
else {
        trigger(Event:DataM_Final, in_msg.Address);
    }
}
else if (in_msg.Type == CoherenceResponseType:DataF_FM ||
         in_msg.Type == CoherenceResponseType:TxnF_FM) {
    if (acksRemaining(in_msg.Address)) {
} }
}
// Events
        trigger(Event:DataFM, in_msg.Address);
    }
    else {
        trigger(Event:DataFM_Final, in_msg.Address);
} }
else if (in_msg.Type == CoherenceResponseType:DACK) {
    trigger(Event:DACK, in_msg.Address);
}
else {
    assert(false);
}
    action(a_issueGETS, "a", desc="Issue GETS") {
        peek(mandatoryQueue_in, CacheMsg) {
            // Make a normal request to the home/L2 cache.
            enqueue(requestNetwork_out, RequestMsg,
latency="L1_REQUEST_LATENCY") {
                out_msg.Address := address;
                out_msg.Type := CoherenceRequestType:GETS;
                //out_msg.SenderMachine := MachineType:L1Cache;
                out_msg.Requestor := machineID;
out_msg.Destination.add(map_L1CacheMachId_to_L2Cache(address,machineID));
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Prefetch := in_msg.Prefetch;
                out_msg.AccessMode := in_msg.AccessMode;
                //out_msg.ConflictMachs := machineID;
}
            // Broadcast request to L1 caches
            enqueue(requestNetwork_out, RequestMsg,
latency="L1_REQUEST_LATENCY") {
                out_msg.Address := address;
} }
}
out_msg.Type := CoherenceRequestType:GETS;
//out_msg.SenderMachine := MachineType:L1Cache;
out_msg.Requestor := machineID;
out_msg.Destination := getOtherLocalL1IDs(machineID);
out_msg.MessageSize := MessageSizeType:Control;
out_msg.Prefetch := in_msg.Prefetch;
out_msg.AccessMode := in_msg.AccessMode;
    action(b_issueGETX, "b", desc="Issue GETX") {
        peek(mandatoryQueue_in, CacheMsg) {
            // Make a normal request to the home/L2 cache.
            enqueue(requestNetwork_out, RequestMsg,
latency="L1_REQUEST_LATENCY") {
                out_msg.Address := address;
                out_msg.Type := CoherenceRequestType:GETX;
                //out_msg.SenderMachine := MachineType:L1Cache;
                out_msg.Requestor := machineID;
out_msg.Destination.add(map_L1CacheMachId_to_L2Cache(address,machineID));
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Prefetch := in_msg.Prefetch;
                out_msg.AccessMode := in_msg.AccessMode;
                //out_msg.ConflictMachs := machineID;
}
            // Broadcast request to L1 caches
            enqueue(requestNetwork_out, RequestMsg,
latency="L1_REQUEST_LATENCY") {
                out_msg.Address := address;
                out_msg.Type := CoherenceRequestType:GETX;
                //out_msg.SenderMachine := MachineType:L1Cache;
                out_msg.Requestor := machineID;
                out_msg.Destination := getOtherLocalL1IDs(machineID);
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Prefetch := in_msg.Prefetch;
                out_msg.AccessMode := in_msg.AccessMode;
} }
}
    action(ai_issueGETINSTR, "ai", desc="Issue GETINSTR") {
        peek(mandatoryQueue_in, CacheMsg) {
            // Make a normal request to the home/L2 cache.
            enqueue(requestNetwork_out, RequestMsg,
latency="L1_REQUEST_LATENCY") {
                out_msg.Address := address;
                out_msg.Type := CoherenceRequestType:GET_INSTR;
                //out_msg.SenderMachine := MachineType:L1Cache;
                out_msg.Requestor := machineID;
out_msg.Destination.add(map_L1CacheMachId_to_L2Cache(address,machineID));
                out_msg.MessageSize := MessageSizeType:Control;
                out_msg.Prefetch := in_msg.Prefetch;
                out_msg.AccessMode := in_msg.AccessMode;
                //out_msg.ConflictMachs := machineID;
}
            // Broadcast request to L1 caches
            enqueue(requestNetwork_out, RequestMsg,
latency="L1_REQUEST_LATENCY") {
} }
}
out_msg.Address := address;
out_msg.Type := CoherenceRequestType:GET_INSTR;
//out_msg.SenderMachine := MachineType:L1Cache;
out_msg.Requestor := machineID;
out_msg.Destination := getOtherLocalL1IDs(machineID);
out_msg.MessageSize := MessageSizeType:Control;
out_msg.Prefetch := in_msg.Prefetch;
out_msg.AccessMode := in_msg.AccessMode;
    action(c_sendCnclHome, "c", desc="Issue cancel to home") {
        enqueue(requestNetwork_out, RequestMsg, latency="L1_REQUEST_LATENCY")
{
            out_msg.Address := address;
            out_msg.Type := CoherenceRequestType:CNCL;
            //out_msg.SenderMachine := MachineType:L1Cache;
            out_msg.Requestor := machineID;
out_msg.Destination.add(map_L1CacheMachId_to_L2Cache(address,machineID));
            out_msg.MessageSize := MessageSizeType:Control;
            out_msg.AccessMode := L1_TBEs[address].AccessMode;
            out_msg.Prefetch := L1_TBEs[address].Prefetch;
            out_msg.ConflictMachs := L1_TBEs[address].ConflictMachs;
} }
    action(d_sendReadHome, "d", desc="Issue read to home") {
        enqueue(requestNetwork_out, RequestMsg, latency="L1_REQUEST_LATENCY")
{
            out_msg.Address := address;
            out_msg.Type := CoherenceRequestType:READ;
            //out_msg.SenderMachine := MachineType:L1Cache;
            out_msg.Requestor := machineID;
out_msg.Destination.add(map_L1CacheMachId_to_L2Cache(address,machineID));
            out_msg.MessageSize := MessageSizeType:Control;
            out_msg.AccessMode := L1_TBEs[address].AccessMode;
            out_msg.Prefetch := L1_TBEs[address].Prefetch;
            out_msg.ConflictMachs := L1_TBEs[address].ConflictMachs;
} }
    action(df_sendForwardDataToRequestor, "df", desc="send data to requestor
as forward") {
        peek(requestNetwork_in, RequestMsg) {
            enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L2_RESPONSE_LATENCY") {
                out_msg.Address := address;
                out_msg.Type := CoherenceResponseType:DataF_F;
                out_msg.SenderMachine := MachineType:L1Cache;
                out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
} }
}
out_msg.Dirty := getL1CacheEntry(address).Dirty;
out_msg.Sender := machineID;
out_msg.Destination.add(in_msg.Requestor);
out_msg.MessageSize := MessageSizeType:Response_Data;
out_msg.SenderMachine := MachineType:L1Cache;
    action(de_sendExclusiveDataToRequestor, "de", desc="send data to
requestor as exclusive") {
        peek(requestNetwork_in, RequestMsg) {
            enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L2_RESPONSE_LATENCY") {
                out_msg.Address := address;
} }
}
out_msg.Type := CoherenceResponseType:DataF_E;
out_msg.SenderMachine := MachineType:L1Cache;
out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
out_msg.Dirty := getL1CacheEntry(address).Dirty;
out_msg.Sender := machineID;
out_msg.Destination.add(in_msg.Requestor);
out_msg.MessageSize := MessageSizeType:Response_Data;
out_msg.SenderMachine := MachineType:L1Cache;
    action(dm_sendModifiedDataToRequestor, "dm", desc="send data to requestor
as modified") {
        peek(requestNetwork_in, RequestMsg) {
            enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L2_RESPONSE_LATENCY") {
                out_msg.Address := address;
                out_msg.Type := CoherenceResponseType:DataF_M;
                out_msg.SenderMachine := MachineType:L1Cache;
                out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
                out_msg.Dirty := getL1CacheEntry(address).Dirty;
                out_msg.Sender := machineID;
                out_msg.Destination.add(in_msg.Requestor);
} }
} }
}
    out_msg.MessageSize := MessageSizeType:Response_Data;
    out_msg.SenderMachine := MachineType:L1Cache;
}
    action(dfm_sendForwardModifiedDataToRequestor, "dfm", desc="send data to
requestor as forwarded/modified") {
        peek(requestNetwork_in, RequestMsg) {
            enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L2_RESPONSE_LATENCY") {
                out_msg.Address := address;
out_msg.Type := CoherenceResponseType:DataF_FM;
out_msg.SenderMachine := MachineType:L1Cache;
out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
out_msg.Dirty := getL1CacheEntry(address).Dirty;
out_msg.Sender := machineID;
out_msg.Destination.add(in_msg.Requestor);
out_msg.MessageSize := MessageSizeType:Response_Data;
out_msg.SenderMachine := MachineType:L1Cache;
    action(di_sendIACKToRequestor, "di", desc="send IACK to requestor") {
        peek(requestNetwork_in, RequestMsg) {
            enqueue(responseNetwork_out, ResponseMsg,
                latency="L1_REQUEST_LATENCY") {
    }   }
}
out_msg.Address := address;
out_msg.Type := CoherenceResponseType:IACK;
out_msg.SenderMachine := MachineType:L1Cache;
out_msg.Dirty := false;
out_msg.Sender := machineID;
out_msg.Destination.add(in_msg.Requestor);
out_msg.MessageSize := MessageSizeType:Response_Control;
    action(ds_sendSACKToRequestor, "ds", desc="send SACK to requestor") {
        peek(requestNetwork_in, RequestMsg) {
            enqueue(responseNetwork_out, ResponseMsg,
latency="L1_REQUEST_LATENCY") {
} }
}
out_msg.Address := address;
out_msg.Type := CoherenceResponseType:SACK;
out_msg.SenderMachine := MachineType:L1Cache;
out_msg.Dirty := false;
out_msg.Sender := machineID;
out_msg.Destination.add(in_msg.Requestor);
out_msg.MessageSize := MessageSizeType:Response_Control;
    action(dd_sendDACKToRequestor, "dd", desc="send DACK to forwarder") {
        enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L1_REQUEST_LATENCY") {
            out_msg.Address := address;
            out_msg.Type := CoherenceResponseType:DACK;
            out_msg.SenderMachine := MachineType:L1Cache;
            out_msg.Dirty := false;
            out_msg.Sender := machineID;
            out_msg.Destination.add(L1_TBEs[address].L1_FwdData);
            out_msg.MessageSize := MessageSizeType:Response_Control;
} }
    action(sc_sendConflict, "sc", desc="Send conflict to requestor") {
        peek(requestNetwork_in, RequestMsg) {
            enqueue(responseNetwork_out, ResponseMsg,
latency="L1_REQUEST_LATENCY") {
                out_msg.Address := address;
                out_msg.Type := CoherenceResponseType:Conflict;
                out_msg.SenderMachine := MachineType:L1Cache;
                out_msg.Dirty := false;
                out_msg.Sender := machineID;
                out_msg.Destination.add(in_msg.Requestor);
                out_msg.MessageSize := MessageSizeType:Response_Control;
} }
}
    action(tm_transferModified, "tm", desc="Transfers the data as modified
state - as ordered by home") {
        enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L2_RESPONSE_LATENCY") {
            out_msg.Address := address;
            out_msg.Type := CoherenceResponseType:TxnF_M;
            out_msg.SenderMachine := MachineType:L1Cache;
            out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
            out_msg.Dirty := getL1CacheEntry(address).Dirty;
            out_msg.Sender := machineID;
            out_msg.Destination.add(L1_TBEs[address].TransferMachine);
            out_msg.MessageSize := MessageSizeType:Response_Data;
            out_msg.SenderMachine := MachineType:L1Cache;
} }
    action(te_transferExclusive, "te", desc="Transfers the data as exclusive
state - as ordered by home") {
        enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L2_RESPONSE_LATENCY") {
            out_msg.Address := address;
            out_msg.Type := CoherenceResponseType:TxnF_E;
            out_msg.SenderMachine := MachineType:L1Cache;
            out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
            out_msg.Dirty := getL1CacheEntry(address).Dirty;
            out_msg.Sender := machineID;
            out_msg.Destination.add(L1_TBEs[address].TransferMachine);
            out_msg.MessageSize := MessageSizeType:Response_Data;
            out_msg.SenderMachine := MachineType:L1Cache;
} }
    action(tfm_transferForwardModified, "tfm", desc="Transfers the data as
forward/modified state - as ordered by home") {
        enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L2_RESPONSE_LATENCY") {
            out_msg.Address := address;
            out_msg.Type := CoherenceResponseType:TxnF_FM;
            out_msg.SenderMachine := MachineType:L1Cache;
            out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
            out_msg.Dirty := getL1CacheEntry(address).Dirty;
            out_msg.Sender := machineID;
            out_msg.Destination.add(L1_TBEs[address].TransferMachine);
            out_msg.MessageSize := MessageSizeType:Response_Data;
            out_msg.SenderMachine := MachineType:L1Cache;
} }
    action(tf_transferForward, "tf", desc="Transfers the data as forward
state - as ordered by home") {
        enqueue(dataResponseNetwork_out, ResponseMsg,
latency="L2_RESPONSE_LATENCY") {
            out_msg.Address := address;
            out_msg.Type := CoherenceResponseType:TxnF_F;
            out_msg.SenderMachine := MachineType:L1Cache;
            out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
            out_msg.Dirty := getL1CacheEntry(address).Dirty;
            out_msg.Sender := machineID;
            out_msg.Destination.add(L1_TBEs[address].TransferMachine);
            out_msg.MessageSize := MessageSizeType:Response_Data;
            out_msg.SenderMachine := MachineType:L1Cache;
} }
    // action(g_issuePUTX, "g", desc="send data to the L2 cache") {

//     enqueue(requestNetwork_out, RequestMsg,
latency="L2_RESPONSE_LATENCY") {
    //         out_msg.Address := address;
    //         out_msg.Type := CoherenceRequestType:PUTX;
    //         out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
    //         out_msg.Dirty := getL1CacheEntry(address).Dirty;
    //         out_msg.Requestor:= machineID;
    //         out_msg.Destination.add(map_L1CacheMachId_to_L2Cache(address,
machineID));
    //         //if (getL1CacheEntry(address).Dirty) {
    //         out_msg.MessageSize := MessageSizeType:Writeback_Data;
// //}
// //else {
    //         //    out_msg.MessageSize :=
MessageSizeType:Writeback_Control;
// //}
// } // }
    action(gf_issueL2FowardModified, "gfm", desc="send data to the L2 cache
as forward modified") {
        enqueue(requestNetwork_out, RequestMsg,
latency="L2_RESPONSE_LATENCY") {
            out_msg.Address := address;
            out_msg.Type := CoherenceRequestType:DataFM;
            out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
            out_msg.Dirty := getL1CacheEntry(address).Dirty;
            out_msg.Requestor:= machineID;
            out_msg.Destination.add(map_L1CacheMachId_to_L2Cache(address,
machineID));
            //if (getL1CacheEntry(address).Dirty) {
            out_msg.MessageSize := MessageSizeType:Writeback_Data;
            //}
            //else {
            //    out_msg.MessageSize := MessageSizeType:Writeback_Control;
            //}
} }
    action(gm_issueL2Modified, "gm", desc="send data to the L2 cache as
modified") {
        enqueue(requestNetwork_out, RequestMsg,
latency="L2_RESPONSE_LATENCY") {
            out_msg.Address := address;
            out_msg.Type := CoherenceRequestType:DataM;
            out_msg.DataBlk := getL1CacheEntry(address).DataBlk;
            out_msg.Dirty := getL1CacheEntry(address).Dirty;
            out_msg.Requestor:= machineID;
            out_msg.Destination.add(map_L1CacheMachId_to_L2Cache(address,
machineID));
            //if (getL1CacheEntry(address).Dirty) {
            out_msg.MessageSize := MessageSizeType:Writeback_Data;
            //}
            //else {
            //    out_msg.MessageSize := MessageSizeType:Writeback_Control;
            //}
} }
    action(h_load_hit, "h", desc="Notify sequencer the load completed.") {
        DEBUG_EXPR(getL1CacheEntry(address).DataBlk);
        sequencer.readCallback(address, getL1CacheEntry(address).DataBlk);
}
    action(hh_store_hit, "\h", desc="Notify sequencer that store completed.")
{
        DEBUG_EXPR(getL1CacheEntry(address).DataBlk);
        sequencer.writeCallback(address, getL1CacheEntry(address).DataBlk);
        getL1CacheEntry(address).Dirty := true;
}
    action(i_allocateTBE, "i", desc="Allocate TBE") {
        check_allocate(L1_TBEs);
        L1_TBEs.allocate(address);
        peek(mandatoryQueue_in, CacheMsg) {
            L1_TBEs[address].Prefetch := in_msg.Prefetch;
        }
        L1_TBEs[address].Dirty := getL1CacheEntry(address).Dirty;
        L1_TBEs[address].DataBlk := getL1CacheEntry(address).DataBlk;
        // Signifies that there is no conflict -- yet
        //L1_TBEs[address].ConflictingMachine := machineID;
        // Signifies that we are not transferring to anyone
        L1_TBEs[address].TransferMachine := machineID;
    }
    action(v_recordForwarder, "v", desc="Records which cache sent us the
data, so we can send a DACK") {
        peek(dataResponseNetwork_in, ResponseMsg) {
            L1_TBEs[address].L1_FwdData := in_msg.Sender;
        }
}
    /*action(v_responseRecordForwarder, "rv", desc="Records which cache sent
us the data, so we can send a DACK (From response network)") {
        peek(responseNetwork_in, ResponseMsg) {
            L1_TBEs[address].L1_FwdData := in_msg.Sender;
} }*/
    action(cr_recordConflictMachineRequest, "cr", desc="Records the
conflicting machine when the conflict is known from a request") {
        peek(requestNetwork_in, RequestMsg) {
            if (L1_TBEs[address].ConflictMachs.contains(in_msg.Requestor) ==
false) {
false) {
} }
    L1_TBEs[address].ConflictMachs.add(in_msg.Requestor);
}
if (L1_TBEs[address].RequestMach.contains(in_msg.Requestor) ==
    L1_TBEs[address].RequestMach.add(in_msg.Requestor);
}
    action(cc_recordConflictMachineResponse, "\c", desc="Records the
conflicting machine when the conflict is known from a response") {
        peek(responseNetwork_in, ResponseMsg) {
            if (L1_TBEs[address].ConflictMachs.contains(in_msg.Sender) ==
false) {
} }
    L1_TBEs[address].ConflictMachs.add(in_msg.Sender);
}
    action(ct_recordTransferMachine, "ct", desc="Records the machine to
transfer the data to") {
        peek(responseNetwork_in, ResponseMsg) {
            L1_TBEs[address].TransferMachine := in_msg.Transfer;
} }
    action(o_popIncomingResponseQueue, "o", desc="Pop Incoming Response queue
and profile the delay within this virtual network") {
        profileMsgDelay(1, responseNetwork_in.dequeue_getDelayCycles());
    }
    action(od_popIncomingDataResponseQueue, "od", desc="Pop Incoming Data
Response queue and profile the delay within this virtual network") {
        profileMsgDelay(4, dataResponseNetwork_in.dequeue_getDelayCycles());
    }
    action(s_deallocateTBE, "s", desc="Deallocate TBE if it exists") {
        if (L1_TBEs.isPresent(address)) {
            L1_TBEs.deallocate(address);
        }
}
    action(u_writeDataToL1Cache, "u", desc="Write data to cache from
forwarded L1 data") {
        peek(dataResponseNetwork_in, ResponseMsg) {
          getL1CacheEntry(address).DataBlk := in_msg.DataBlk;
            getL1CacheEntry(address).Dirty := in_msg.Dirty;
        }
}
    action(ru_responseWriteDataToL1Cache, "ru", desc="Write data to cache
from forwarded L1 data (From response network)") {
        peek(responseNetwork_in, ResponseMsg) {
          getL1CacheEntry(address).DataBlk := in_msg.DataBlk;
            getL1CacheEntry(address).Dirty := in_msg.Dirty;
        }
}
    action(uu_writeHomeDataToL1Cache, "\u", desc="Write data to cache data
from Home") {
        peek(responseNetwork_in, ResponseMsg) {
          getL1CacheEntry(address).DataBlk := in_msg.DataBlk;
            getL1CacheEntry(address).Dirty := in_msg.Dirty;
        }
}
    action(k_popMandatoryQueue, "k", desc="Pop mandatory queue.") {
        mandatoryQueue_in.dequeue();
}
    action(ff_deallocateL1CacheBlock, "\f", desc="Deallocate L1 cache block.
Sets the cache to not present, allowing a replacement in parallel with a
fetch.") {
        if (L1DcacheMemory.isTagPresent(address)) {
            L1DcacheMemory.deallocate(address);
        } else {
            L1IcacheMemory.deallocate(address);
} }
    action(l_popRequestQueue, "l", desc="Pop incoming request queue and
profile the delay within this virtual network") {
        profileMsgDelay(0, requestNetwork_in.dequeue_getDelayCycles());
    }
    action(oo_allocateL1DCacheBlock, "\o", desc="Set L1 D-cache tag equal to
tag of block B.") {
        if (L1DcacheMemory.isTagPresent(address) == false) {
            L1DcacheMemory.allocate(address);
} }
    action(pp_allocateL1ICacheBlock, "\p", desc="Set L1 I-cache tag equal to
tag of block B.") {
        if (L1IcacheMemory.isTagPresent(address) == false) {
            L1IcacheMemory.allocate(address);
} }
    action(rr_recycleRequestQueue, "\r", desc="Send the head of the request
queue to the back of the queue.") {
        requestNetwork_in.recycle();
    }
    action(zz_recycleMandatoryQueue, "\z", desc="Send the head of the
mandatory queue to the back of the queue.") {
        mandatoryQueue_in.recycle();
    }
    // Transitions
    transition({IM, IMF, IMFH, IMH, IS, ISH, ISF, ISFH, EI, MI, FI, OI, ES,
MS, FS, OS,
                IMC, IMHC, IMFC, IMFHC, IMWX, IMWC, ISC, ISFC, ISFHC, ISHC,
ISWX, ISWC,
                ISCI, ISFCI, ISFHCI, ISHCI, ISWXI, FM, FMH, FMC, FMHC, ISFM,
ISFMH, ISFMC, ISFMHC, ISFMCI, ISFMHCI, ISECI, ISMCI, ISEHCI, ISMHCI, WR,
WRH}, L1_Replacement) {
        zz_recycleMandatoryQueue;
    }
    transition({IM, IMH, IMF, IMFH, IMC, IMHC, IMFC, IMFHC, IMWX, IMWC, EI,
MI, FI, OI, ES, MS,
                FS, OS, WB, IS, ISH, ISF, ISFH, ISFM, ISFMH, ISC, ISHC, ISFC,
ISFHC, ISFMC, ISFMHC,
                ISWX, ISWC, ISCI, ISHCI, ISFCI, ISFHCI, ISFMCI, ISFMHCI,
ISECI, ISEHCI, ISMCI,
                ISMHCI, ISWXI, FM, FMH, FMC, FMHC, WR, WRH}, Fwd_Recycle) {
        rr_recycleRequestQueue;
}
    transition({S, F, E, I}, L1_Replacement, I) {
        ff_deallocateL1CacheBlock;
}
    // transition({M, O}, L1_Replacement, WB) {
    //     i_allocateTBE;
    //     g_issuePUTX;
    //     ff_deallocateL1CacheBlock;
    // }
    transition(O, L1_Replacement, WB) {
        i_allocateTBE;
        gf_issueL2FowardModified;
        ff_deallocateL1CacheBlock;
    }
    transition(M, L1_Replacement, WB) {
        i_allocateTBE;
        gm_issueL2Modified;
        ff_deallocateL1CacheBlock;
    }
    transition(WB, WB_Ack, I) {
        s_deallocateTBE;
        o_popIncomingResponseQueue;
}
    transition(WB, {Store, Load, Ifetch}) {
        zz_recycleMandatoryQueue;
}
    transition(WB, {Fwd_GETX, Fwd_GETS, Fwd_GET_INSTR}) {
        rr_recycleRequestQueue;
}
    // TODO: This may be blocking other messages in the network from
completing
    // While waiting for a DACK, no other requests are served.
    transition({FI, EI, MI, OI, FS, ES, MS, OS, WR, WRH}, {Fwd_GETX,
Fwd_GETS, Fwd_GET_INSTR}) {
        rr_recycleRequestQueue;
    }
    // Loads and stores
    // Do not yet have permission to do the store/Transferring the line or
Invalidating
    transition({ISF, ISFH, ISFC, ISFHC, ISFCI, ISFHCI, OI, EI, MI, FI, OS,
ES, MS, FS, ISFM, ISFMH, ISFMC, ISFMHC, ISFMCI, ISFMHCI}, Store) {
        zz_recycleMandatoryQueue;
}
    // Transferring the line or Invalidating
    transition({OI, EI, MI, FI}, {Load, Ifetch}) {
        zz_recycleMandatoryQueue;
    }
    transition(I, Load, IS) {
        oo_allocateL1DCacheBlock;
        i_allocateTBE;
        a_issueGETS;
        k_popMandatoryQueue;
}
    transition(I, Ifetch, IS) {
        pp_allocateL1ICacheBlock;
        i_allocateTBE;
        ai_issueGETINSTR;
        k_popMandatoryQueue;
}
    // States which are legal to read from, can just do the read.
    transition({S, F, E, M, O, IMF, IMFH, ISF, ISFH, IMFC, IMFHC, ISFC,
ISFHC, ISFCI, ISFHCI, FM, FMH, FMC, FMHC, ES, MS, FS, OS,
                ISFM, ISFMH, ISFMC, ISFMHC, ISFMCI, ISFMHCI, ISECI, ISMCI,
ISEHCI, ISMHCI, WR, WRH}, {Load, Ifetch}) {
h_load_hit;
        k_popMandatoryQueue;
    }
    transition(I, Store, IM) {
        oo_allocateL1DCacheBlock;
        i_allocateTBE;
        b_issueGETX;
        k_popMandatoryQueue;
}
    transition(S, Store, IM) {
        i_allocateTBE;
        b_issueGETX;
        k_popMandatoryQueue;
    }
    // States which are legal to write from, can just do the write.
    transition({M, IMF, IMFH, IMFC, IMFHC, FM, FMH, FMC, FMHC, ISMCI, ISMHCI,
WR, WRH}, Store) {
        hh_store_hit;
        k_popMandatoryQueue;
    }
    transition(E, Store, M) {
        hh_store_hit;
        k_popMandatoryQueue;
    }
    // F and O are equivalent here, as the Fwd_GetX will invalidate everyone
else, and this node is guaranteed to be the first one to reply to home - not
true!!
    /*transition({F, O}, Store, FM) {
        hh_store_hit;
        i_allocateTBE;
        b_issueGETX;
        k_popMandatoryQueue;
}*/
    transition(F, Store, WR) {
        i_allocateTBE;
        b_issueGETX;
        hh_store_hit;
        k_popMandatoryQueue;
    }
    // transition(O, Store, WB) {
// // // }
i_allocateTBE;
g_issuePUTX;
    transition(O, Store, WR) {
        i_allocateTBE;
        b_issueGETX;
        hh_store_hit;
        k_popMandatoryQueue;
}
    // We got the line as exclusive because someother node sent a GetX, and
has not yet gotten the line (to modify it)
    transition(ISECI, Store, ISMCI) {
        hh_store_hit;
        k_popMandatoryQueue;
    }
    transition(ISEHCI, Store, ISMHCI) {
        hh_store_hit;
        k_popMandatoryQueue;
    }
    // Acknowledgement messages
    // IM
    transition(IM, IACK) {
        o_popIncomingResponseQueue;
    }
    transition(IMF, IACK) {
        o_popIncomingResponseQueue;
}
    transition(IM, IACK_Final, IMH) {
        d_sendReadHome;
        o_popIncomingResponseQueue;
}
transition(IMF, IACK_Final, IMFH) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(IM, SACK) {
    o_popIncomingResponseQueue;
}
transition(IMF, SACK) {
    o_popIncomingResponseQueue;
}
transition(IM, SACK_Final, IMH) {
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(IMF, SACK_Final, IMFH) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
// IS
transition({IS, ISF, ISFM}, IACK) {
    o_popIncomingResponseQueue;
}
transition(IS, IACK_Final, ISH) {
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(ISF, IACK_Final, ISFH) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFM, IACK_Final, ISFMH) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition({IS, ISF, ISFM}, SACK) {
    o_popIncomingResponseQueue;
}
transition(IS, SACK_Final, ISH) {
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(ISF, SACK_Final, ISFH) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFM, SACK_Final, ISFMH) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
// FM
transition(FM, IACK) {
    o_popIncomingResponseQueue;
}
transition(FM, SACK) {
    o_popIncomingResponseQueue;
}
transition(FM, IACK_Final, FMH) {
    c_sendCnclHome;
        o_popIncomingResponseQueue;
    }
    transition(FM, SACK_Final, FMH) {
        c_sendCnclHome;
        o_popIncomingResponseQueue;
    }
    // Forwarded data from L1/ cache
    transition(IM, {DataE, DataM}, IMF) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        hh_store_hit;
        od_popIncomingDataResponseQueue;
}
    transition(IM, {DataE_Final, DataM_Final}, IMFH) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        c_sendCnclHome;
        hh_store_hit;
        od_popIncomingDataResponseQueue;
    }
    // These transitions occur when there is a forward state present.
    // May need to distinguish this state as one that cannot yet be written
to
    transition(IM, {DataF, DataFM}, IMF) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        hh_store_hit;
        od_popIncomingDataResponseQueue;
}
    // May need to distinguish this state as one that cannot yet be written
to
    transition(IM, {DataF_Final, DataFM_Final}, IMFH) {
        u_writeDataToL1Cache;
    v_recordForwarder;
    c_sendCnclHome;
    hh_store_hit;
    od_popIncomingDataResponseQueue;
}
transition(IS, DataF, ISF) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(IS, {DataFM, DataM}, ISFM) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(IS, DataF_Final, ISFH) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    c_sendCnclHome;
h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(IS, {DataFM_Final, DataM_Final}, ISFMH) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    c_sendCnclHome;
h_load_hit;
    od_popIncomingDataResponseQueue;
}
// Response from home
transition(IMH, DataE_Home, M) {
    uu_writeHomeDataToL1Cache;
    hh_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(IMFH, Ack_Home, M) {
    dd_sendDACKToRequestor;
    //hh_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(ISH, DataE_Home, E) {
    uu_writeHomeDataToL1Cache;
    h_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(ISFH, Ack_Home, F) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(ISFMH, Ack_Home, O) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(FMH, Ack_Home, M) {
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
// Requests from another cache
transition(I, {Fwd_GETX, Fwd_GETS, Fwd_GET_INSTR}) {
    di_sendIACKToRequestor;
    l_popRequestQueue;
}
transition(S, Fwd_GETX, I) {
    ds_sendSACKToRequestor;
    l_popRequestQueue;
}
transition(S, {Fwd_GETS, Fwd_GET_INSTR}) {
    ds_sendSACKToRequestor;
    l_popRequestQueue;
}
transition(F, Fwd_GETX, FI) {
    df_sendForwardDataToRequestor;
    l_popRequestQueue;
}
transition(F, {Fwd_GETS, Fwd_GET_INSTR}, FS) {
    df_sendForwardDataToRequestor;
    l_popRequestQueue;
}
transition(O, Fwd_GETX, OI) {
    dfm_sendForwardModifiedDataToRequestor;
    l_popRequestQueue;
}
transition(O, {Fwd_GETS, Fwd_GET_INSTR}, OS) {
    dfm_sendForwardModifiedDataToRequestor;
    l_popRequestQueue;
}
transition(E, Fwd_GETX, EI) {
    de_sendExclusiveDataToRequestor;
    l_popRequestQueue;
}
transition(E, {Fwd_GETS, Fwd_GET_INSTR}, ES) {
    df_sendForwardDataToRequestor;
    l_popRequestQueue;
}
transition(M, {Fwd_GETS, Fwd_GET_INSTR}, MS) {
    dfm_sendForwardModifiedDataToRequestor;
    l_popRequestQueue;
}
transition(M, Fwd_GETX, MI) {
    dm_sendModifiedDataToRequestor;
    l_popRequestQueue;
}
// Dack transitions
transition({MS, ES, FS, OS}, DACK, S) {
    s_deallocateTBE;
    od_popIncomingDataResponseQueue;
}
transition({MI, EI, FI, OI}, DACK, I) {
    s_deallocateTBE;
    od_popIncomingDataResponseQueue;
}
// Conflict transitions - GetX
// Recieving conflicting requests in non-conflicting state
transition(IM, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}, IMC) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(IM, Conflict, IMC) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(IM, Conflict_Final, IMHC) {
    cc_recordConflictMachineResponse;
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(IMF, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}, IMFC) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(IMF, Conflict, IMFC) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(IMF, Conflict_Final, IMFHC) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
/*transition(IMH, Data_Transfer, MI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    hh_store_hit;
    ct_recordTransferMachine;
    tm_transferModified;
    o_popIncomingResponseQueue;
}*/
/*transition(IMH, Wait, IMWC) {
    o_popIncomingResponseQueue;
}*/
/*transition(IMH, Wait_Transfer, IMWX) {
    ct_recordTransferMachine;
    o_popIncomingResponseQueue;
}*/
transition(IMH, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
transition(IMFH, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
// Transitions when conflicting states exist
transition(IMC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(IMC, {IACK, SACK}) {
    o_popIncomingResponseQueue;
}
transition(IMC, Conflict) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(IMC, {IACK_Final, SACK_Final}, IMHC) {
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(IMC, Conflict_Final, IMHC) {
        cc_recordConflictMachineResponse;
        d_sendReadHome;
        o_popIncomingResponseQueue;
}
    transition(IMC, {DataF, DataE, DataM, DataFM}, IMFC) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        hh_store_hit;
        od_popIncomingDataResponseQueue;
    }
    transition(IMC, {DataF_Final, DataE_Final, DataM_Final, DataFM_Final},
IMFHC) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        hh_store_hit;
        c_sendCnclHome;
        od_popIncomingDataResponseQueue;
}
    transition(IMFC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
        rr_recycleRequestQueue;
}
    transition(IMFC, {IACK, SACK}) {
        o_popIncomingResponseQueue;
}
    transition(IMFC, Conflict) {
        cc_recordConflictMachineResponse;
        o_popIncomingResponseQueue;
}
    transition(IMFC, {IACK_Final, SACK_Final}, IMFHC) {
        c_sendCnclHome;
        o_popIncomingResponseQueue;
    }
transition(IMFC, Conflict_Final, IMFHC) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(IMFHC, Ack_Home, M) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(IMFHC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
transition(IMFHC, Transfer, MI) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tm_transferModified;
    o_popIncomingResponseQueue;
}
transition(IMFHC, Wait, M) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(IMFHC, Wait_Transfer, MI) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tm_transferModified;
    o_popIncomingResponseQueue;
}
transition(IMHC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
    transition(IMHC, {DataF_Final, DataE_Final, DataM_Final, DataFM_Final},
IMFHC) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        hh_store_hit;
        od_popIncomingDataResponseQueue;
}
    transition(IMHC, Data_Transfer, MI) {
        ru_responseWriteDataToL1Cache;
        //v_responseRecordForwarder;
        hh_store_hit;
        ct_recordTransferMachine;
        tm_transferModified;
        o_popIncomingResponseQueue;
}
    transition(IMHC, Wait, IMWC) {
        o_popIncomingResponseQueue;
}
    transition(IMHC, Wait_Transfer, IMWX) {
        ct_recordTransferMachine;
        o_popIncomingResponseQueue;
}
    // Wont be DataF since we are going to exclusive
    transition(IMWC, {DataE_Final, DataM_Final, DataFM_Final, DataF_Final},
M) {
        v_recordForwarder;
        dd_sendDACKToRequestor;
        u_writeDataToL1Cache;
        hh_store_hit;
        s_deallocateTBE;
        od_popIncomingDataResponseQueue;
    }
    transition(IMWC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
        rr_recycleRequestQueue;
    }
    // Wont be DataF since we are going to exclusive
    transition(IMWX, {DataE_Final, DataM_Final, DataFM_Final, DataF_Final},
MI) {
        v_recordForwarder;
        dd_sendDACKToRequestor;
        u_writeDataToL1Cache;
        hh_store_hit;
        tm_transferModified;
        od_popIncomingDataResponseQueue;
}
    transition(IMWX, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
        rr_recycleRequestQueue;
    }
    // Conflicts - GetS
    // Recieving conflicting requests in non-conflicting state
    transition(IS, {Fwd_GETS, Fwd_GET_INSTR}, ISC) {
        cr_recordConflictMachineRequest;
        sc_sendConflict;
        l_popRequestQueue;
}
    transition(IS, Fwd_GETX, ISCI) {
        cr_recordConflictMachineRequest;
        sc_sendConflict;
        l_popRequestQueue;
}
    transition(IS, Conflict, ISC) {
        cc_recordConflictMachineResponse;
        o_popIncomingResponseQueue;
}
transition(IS, Conflict_Final, ISHC) {
    cc_recordConflictMachineResponse;
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(ISF, {Fwd_GETS, Fwd_GET_INSTR}, ISFC) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(ISFM, {Fwd_GETS, Fwd_GET_INSTR}, ISFMC) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(ISF, Fwd_GETX, ISFCI) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(ISFM, Fwd_GETX, ISFMCI) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(ISF, Conflict, ISFC) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(ISFM, Conflict, ISFMC) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(ISF, Conflict_Final, ISFHC) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFM, Conflict_Final, ISFMHC) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
/*transition(ISH, Data_Transfer, FI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    ct_recordTransferMachine;
    tf_transferForward;
    o_popIncomingResponseQueue;
}*/
/*transition(ISH, Wait, ISWC) {
    o_popIncomingResponseQueue;
}*/
/*transition(ISH, Wait_Transfer, ISWX) {
    ct_recordTransferMachine;
    o_popIncomingResponseQueue;
}*/
transition(ISH, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
transition(ISFH, Transfer, FS) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tf_transferForward;
    o_popIncomingResponseQueue;
}
transition(ISFMH, Transfer, OS) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tfm_transferForwardModified;
    o_popIncomingResponseQueue;
}
transition({ISFH, ISFMH}, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
// Transitions when conflicting states exist
transition(ISC, {Fwd_GETS, Fwd_GET_INSTR}) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(ISC, Fwd_GETX, ISCI) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(ISC, {IACK, SACK}) {
    o_popIncomingResponseQueue;
}
transition(ISC, Conflict) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(ISC, {IACK_Final, SACK_Final}, ISHC) {
    d_sendReadHome;
o_popIncomingResponseQueue;
}
transition(ISC, Conflict_Final, ISHC) {
    cc_recordConflictMachineResponse;
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(ISC, DataF, ISFC) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISC, {DataFM, DataM}, ISFMC) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISC, DataF_Final, ISFHC) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    c_sendCnclHome;
    od_popIncomingDataResponseQueue;
}
transition(ISC, {DataFM_Final, DataM_Final}, ISFMHC) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    c_sendCnclHome;
    od_popIncomingDataResponseQueue;
}

transition({ISFC, ISFMC}, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
transition({ISFC, ISFMC}, {IACK, SACK}) {
    o_popIncomingResponseQueue;
}
transition({ISFC, ISFMC}, Conflict) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(ISFC, {IACK_Final, SACK_Final}, ISFHC) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFMC, {IACK_Final, SACK_Final}, ISFMHC) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFC, Conflict_Final, ISFHC) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFMC, Conflict_Final, ISFMHC) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFHC, Ack_Home, F) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(ISFMHC, Ack_Home, O) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition({ISFHC, ISFMHC}, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
transition(ISFHC, Transfer, FS) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tf_transferForward;
    o_popIncomingResponseQueue;
}
transition(ISFMHC, Transfer, OS) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tfm_transferForwardModified;
    o_popIncomingResponseQueue;
}
transition(ISFHC, Wait, F) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(ISFMHC, Wait, O) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(ISFHC, Wait_Transfer, FS) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tf_transferForward;
    o_popIncomingResponseQueue;
}
transition(ISFMHC, Wait_Transfer, OS) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tfm_transferForwardModified;
    o_popIncomingResponseQueue;
}
transition(ISHC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
transition(ISHC, DataF_Final, ISFHC) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISHC, {DataFM_Final, DataM_Final}, ISFMHC) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISHC, Data_Transfer, FS) {
    ru_responseWriteDataToL1Cache;
    //v_responseRecordForwarder;
    h_load_hit;
    ct_recordTransferMachine;
    tf_transferForward;
    o_popIncomingResponseQueue;
}
transition(ISHC, Wait, ISWC) {
    o_popIncomingResponseQueue;
}
transition(ISHC, Wait_Transfer, ISWX) {
    ct_recordTransferMachine;
    o_popIncomingResponseQueue;
}
transition(ISWC, DataF_Final, F) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    s_deallocateTBE;
    od_popIncomingDataResponseQueue;
}
transition(ISWC, DataFM_Final, O) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    s_deallocateTBE;
    od_popIncomingDataResponseQueue;
}
transition(ISWC, DataE_Final, E) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    s_deallocateTBE;
    od_popIncomingDataResponseQueue;
}
transition(ISWC, DataM_Final, M) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    s_deallocateTBE;
    od_popIncomingDataResponseQueue;
}
transition(ISWC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
transition(ISWX, DataF_Final, FS) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    tf_transferForward;
    od_popIncomingDataResponseQueue;
}
transition(ISWX, DataFM_Final, OS) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    tfm_transferForwardModified;
    od_popIncomingDataResponseQueue;
}
transition(ISWX, DataE_Final, ES) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    tf_transferForward;
    od_popIncomingDataResponseQueue;
}
transition(ISWX, DataM_Final, MS) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    tfm_transferForwardModified;
    od_popIncomingDataResponseQueue;
}
transition(ISWX, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
// Conflicts S-M but invalidating
// Transitions when conflicting states exist
transition(ISCI, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(ISCI, {IACK, SACK}) {
    o_popIncomingResponseQueue;
}
transition(ISCI, Conflict) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(ISCI, {IACK_Final, SACK_Final}, ISHCI) {
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(ISCI, Conflict_Final, ISHCI) {
    cc_recordConflictMachineResponse;
    d_sendReadHome;
    o_popIncomingResponseQueue;
}
transition(ISCI, DataF, ISFCI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISCI, DataFM, ISFMCI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISCI, DataE, ISECI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISCI, DataM, ISMCI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISCI, DataF_Final, ISFHCI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    c_sendCnclHome;
    od_popIncomingDataResponseQueue;
}
    transition(ISCI, DataFM_Final, ISFMHCI) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        h_load_hit;
        c_sendCnclHome;
        od_popIncomingDataResponseQueue;
    }
    transition(ISCI, DataE_Final, ISEHCI) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        h_load_hit;
        c_sendCnclHome;
        od_popIncomingDataResponseQueue;
    }
    transition(ISCI, DataM_Final, ISMHCI) {
        u_writeDataToL1Cache;
        v_recordForwarder;
        h_load_hit;
        c_sendCnclHome;
        od_popIncomingDataResponseQueue;
    }
    transition({ISFCI, ISFMCI, ISECI, ISMCI}, {Fwd_GETS, Fwd_GET_INSTR,
Fwd_GETX}) {
        rr_recycleRequestQueue;
    }
    transition({ISFCI, ISFMCI, ISECI, ISMCI}, {IACK, SACK}) {
        o_popIncomingResponseQueue;
}
    transition({ISFCI, ISFMCI, ISECI, ISMCI}, Conflict) {
        cc_recordConflictMachineResponse;
        o_popIncomingResponseQueue;
    }
    transition(ISFCI, {IACK_Final, SACK_Final}, ISFHCI) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFMCI, {IACK_Final, SACK_Final}, ISFMHCI) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISECI, {IACK_Final, SACK_Final}, ISEHCI) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISMCI, {IACK_Final, SACK_Final}, ISMHCI) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFCI, Conflict_Final, ISFHCI) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISFMCI, Conflict_Final, ISFMHCI) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISECI, Conflict_Final, ISEHCI) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(ISMCI, Conflict_Final, ISMHCI) {
    cc_recordConflictMachineResponse;
        c_sendCnclHome;
        o_popIncomingResponseQueue;
    }
    // The Fwd_GetX that sent us into an IS...I state has been dealt with
already
    transition(ISFHCI, Ack_Home, F) {
        dd_sendDACKToRequestor;
        s_deallocateTBE;
        o_popIncomingResponseQueue;
}
    transition(ISFMHCI, Ack_Home, O) {
        dd_sendDACKToRequestor;
        s_deallocateTBE;
        o_popIncomingResponseQueue;
}
    transition(ISEHCI, Ack_Home, E) {
        dd_sendDACKToRequestor;
        s_deallocateTBE;
        o_popIncomingResponseQueue;
}
    transition(ISMHCI, Ack_Home, M) {
        dd_sendDACKToRequestor;
        s_deallocateTBE;
        o_popIncomingResponseQueue;
}
    transition({ISFHCI, ISFMHCI, ISEHCI, ISMHCI}, {Fwd_GETS, Fwd_GET_INSTR,
Fwd_GETX}) {
        rr_recycleRequestQueue;
    }
    transition(ISFHCI, Transfer, FI) {
        dd_sendDACKToRequestor;
        ct_recordTransferMachine;
        tf_transferForward;
        o_popIncomingResponseQueue;
    }
    transition(ISFMHCI, Transfer, OI) {
        dd_sendDACKToRequestor;
        ct_recordTransferMachine;
        tfm_transferForwardModified;
        o_popIncomingResponseQueue;
}
    transition(ISEHCI, Transfer, EI) {
        dd_sendDACKToRequestor;
        ct_recordTransferMachine;
        te_transferExclusive;
        o_popIncomingResponseQueue;
}
    transition(ISMHCI, Transfer, MI) {
        dd_sendDACKToRequestor;
        ct_recordTransferMachine;
        tm_transferModified;
        o_popIncomingResponseQueue;
}
    // The Fwd_GetX that sent us into an IS...I state has been dealt with
already
    transition(ISFHCI, Wait, F) {
        dd_sendDACKToRequestor;
        s_deallocateTBE;
        o_popIncomingResponseQueue;
}
    transition(ISFMHCI, Wait, O) {
        dd_sendDACKToRequestor;
        s_deallocateTBE;
        o_popIncomingResponseQueue;
    }
    transition(ISEHCI, Wait, E) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(ISMHCI, Wait, M) {
    dd_sendDACKToRequestor;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
}
transition(ISFHCI, Wait_Transfer, FI) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tf_transferForward;
    o_popIncomingResponseQueue;
}
transition(ISFMHCI, Wait_Transfer, OI) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tfm_transferForwardModified;
    o_popIncomingResponseQueue;
}
transition(ISEHCI, Wait_Transfer, EI) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    te_transferExclusive;
    o_popIncomingResponseQueue;
}
transition(ISMHCI, Wait_Transfer, MI) {
    dd_sendDACKToRequestor;
    ct_recordTransferMachine;
    tm_transferModified;
    o_popIncomingResponseQueue;
}
transition(ISHCI, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
transition(ISHCI, DataF_Final, ISFHCI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISHCI, DataFM_Final, ISFMHCI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISHCI, DataE_Final, ISEHCI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISHCI, DataM_Final, ISMHCI) {
    u_writeDataToL1Cache;
    v_recordForwarder;
    h_load_hit;
    od_popIncomingDataResponseQueue;
}
transition(ISHCI, Data_Transfer, FI) {
    ru_responseWriteDataToL1Cache;
    //v_responseRecordForwarder;
    h_load_hit;
    ct_recordTransferMachine;
    tf_transferForward;
    o_popIncomingResponseQueue;
}
// Transfer out of IS...I states due to Wait response
transition(ISHCI, Wait, ISWC) {
    o_popIncomingResponseQueue;
}
transition(ISHCI, Wait_Transfer, ISWXI) {
    ct_recordTransferMachine;
    o_popIncomingResponseQueue;
}
transition(ISWXI, DataF_Final, FI) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    tf_transferForward;
    od_popIncomingDataResponseQueue;
}
transition(ISWXI, DataFM_Final, OI) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    tfm_transferForwardModified;
    od_popIncomingDataResponseQueue;
}
transition(ISWXI, DataE_Final, EI) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    te_transferExclusive;
    od_popIncomingDataResponseQueue;
}
transition(ISWXI, DataM_Final, MI) {
    v_recordForwarder;
    dd_sendDACKToRequestor;
    u_writeDataToL1Cache;
    h_load_hit;
    tm_transferModified;
    od_popIncomingDataResponseQueue;
}
transition(ISWXI, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
// Conflicts F-M
// Recieving conflicting requests in non-conflicting state
transition(FM, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}, FMC) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(FM, Conflict, FMC) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(FM, Conflict_Final, FMHC) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(FMH, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
// Transitions when conflicting states exist
transition(FMC, IACK) {
    o_popIncomingResponseQueue;
}
transition(FMC, SACK) {
    o_popIncomingResponseQueue;
}
transition(FMC, IACK_Final, FMHC) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(FMC, SACK_Final, FMHC) {
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(FMC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    cr_recordConflictMachineRequest;
    sc_sendConflict;
    l_popRequestQueue;
}
transition(FMC, Conflict) {
    cc_recordConflictMachineResponse;
    o_popIncomingResponseQueue;
}
transition(FMC, Conflict_Final, FMHC) {
    cc_recordConflictMachineResponse;
    c_sendCnclHome;
    o_popIncomingResponseQueue;
}
transition(FMHC, {Fwd_GETS, Fwd_GET_INSTR, Fwd_GETX}) {
    rr_recycleRequestQueue;
}
    transition(FMHC, Ack_Home, M) {
        s_deallocateTBE;
        //s_deallocateTBE;
        o_popIncomingResponseQueue;
}
    transition(FMHC, Transfer, MI) {
        ct_recordTransferMachine;
        tm_transferModified;
        o_popIncomingResponseQueue;
    }
    // IS forwarded FM states
    // Extra requests! These are GetS/X requests from a L1 cache which this
cache is already transferring too
    // This prevents the request from being recycled until we recieve a DACK,
then being treated as a new request.
    /*transition({MI, EI, FI, OI, MS, ES, FS, OS, IMWX, ISWX, ISWXI},
Extra_Request) {
        l_popRequestQueue;
    }*/
    // TODO: if differentiating between I and S ACK, need to change this
transition
    transition({MI, EI, FI, OI, MS, ES, FS, OS, IMWX, IMWC, ISWX, ISWC,
ISWXI}, {Extra_Fwd_GETS, Extra_Fwd_GET_INSTR}) {
        di_sendIACKToRequestor;
        l_popRequestQueue;
    }
    transition({MI, EI, FI, OI, IMWX, ISWXI}, Extra_Fwd_GETX) {
        di_sendIACKToRequestor;
        l_popRequestQueue;
}
transition(MS, Extra_Fwd_GETX, MI) {
    di_sendIACKToRequestor;
    l_popRequestQueue;
}
transition(ES, Extra_Fwd_GETX, EI) {
    di_sendIACKToRequestor;
    l_popRequestQueue;
}
transition(FS, Extra_Fwd_GETX, FI) {
    di_sendIACKToRequestor;
    l_popRequestQueue;
}
transition(OS, Extra_Fwd_GETX, OI) {
    di_sendIACKToRequestor;
    l_popRequestQueue;
}
transition(ISWX, Extra_Fwd_GETX, ISWXI) {
    di_sendIACKToRequestor;
    l_popRequestQueue;
}
transition(ISWC, Extra_Fwd_GETX, ISWXI) {
    di_sendIACKToRequestor;
    l_popRequestQueue;
}
transition(IMWC, Extra_Fwd_GETX, IMWX) {
    di_sendIACKToRequestor;
    l_popRequestQueue;
}
// WR, WRH
    // TODO: if responding to conflicts, must respond to requests?
    transition(WR, {IACK, SACK}){
        o_popIncomingResponseQueue;
}
    transition(WR, {IACK_Final, SACK_Final}, WRH){
        c_sendCnclHome;
        o_popIncomingResponseQueue;
    }
    transition(WR, Conflict){
        cc_recordConflictMachineResponse;
        o_popIncomingResponseQueue;
}
    transition(WR, Conflict_Final, WRH){
        cc_recordConflictMachineResponse;
        c_sendCnclHome;
        o_popIncomingResponseQueue;
}
    transition(WRH, Transfer, MI){
        ct_recordTransferMachine;
        tm_transferModified;
        o_popIncomingResponseQueue;
}
    transition(WRH, Ack_Home, M){
        s_deallocateTBE;
        o_popIncomingResponseQueue;
} }
